import{_ as s,c as i,o as t,ag as e}from"./chunks/framework.CA53vVaN.js";const c=JSON.parse('{"title":"Worker Cache 性能分析总结","description":"","frontmatter":{},"headers":[],"relativePath":"katex-cache-analysis.zh-CN.md","filePath":"katex-cache-analysis.zh-CN.md"}'),n={name:"katex-cache-analysis.zh-CN.md"};function l(h,a,r,p,d,k){return t(),i("div",null,[...a[0]||(a[0]=[e(`<h1 id="worker-cache-性能分析总结" tabindex="-1">Worker Cache 性能分析总结 <a class="header-anchor" href="#worker-cache-性能分析总结" aria-label="Permalink to &quot;Worker Cache 性能分析总结&quot;">​</a></h1><h2 id="快速回答" tabindex="-1">快速回答 <a class="header-anchor" href="#快速回答" aria-label="Permalink to &quot;快速回答&quot;">​</a></h2><p><strong>Worker 的 cache 非常重要且有意义！</strong></p><h2 id="核心价值" tabindex="-1">核心价值 <a class="header-anchor" href="#核心价值" aria-label="Permalink to &quot;核心价值&quot;">​</a></h2><h3 id="_1-性能提升巨大-🚀" tabindex="-1">1. <strong>性能提升巨大</strong> 🚀 <a class="header-anchor" href="#_1-性能提升巨大-🚀" aria-label="Permalink to &quot;1. **性能提升巨大** 🚀&quot;">​</a></h3><ul><li>Cache 命中时间: <strong>~0.01ms</strong></li><li>Worker 渲染时间: <strong>5-50ms</strong></li><li>提升倍数: <strong>500-5000x</strong></li></ul><h3 id="_2-避免跨线程通信开销-📡" tabindex="-1">2. <strong>避免跨线程通信开销</strong> 📡 <a class="header-anchor" href="#_2-避免跨线程通信开销-📡" aria-label="Permalink to &quot;2. **避免跨线程通信开销** 📡&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>无 Cache: 主线程 → Worker → 渲染 → 主线程 (每次 1-2ms 开销)</span></span>
<span class="line"><span>有 Cache: 内存读取 → 立即返回 (&lt;0.01ms)</span></span></code></pre></div><h3 id="_3-内存占用极小-💾" tabindex="-1">3. <strong>内存占用极小</strong> 💾 <a class="header-anchor" href="#_3-内存占用极小-💾" aria-label="Permalink to &quot;3. **内存占用极小** 💾&quot;">​</a></h3><ul><li>单条缓存: ~180 bytes</li><li>200 条缓存: ~36 KB</li><li>结论: <strong>可以忽略不计</strong></li></ul><h2 id="实际测量数据" tabindex="-1">实际测量数据 <a class="header-anchor" href="#实际测量数据" aria-label="Permalink to &quot;实际测量数据&quot;">​</a></h2><h3 id="测试场景-真实文档-50-个公式" tabindex="-1">测试场景：真实文档（50 个公式） <a class="header-anchor" href="#测试场景-真实文档-50-个公式" aria-label="Permalink to &quot;测试场景：真实文档（50 个公式）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>方案</th><th>总耗时</th><th>主线程阻塞</th><th>缓存命中率</th></tr></thead><tbody><tr><td>无优化（直接渲染）</td><td>250ms</td><td>250ms</td><td>0%</td></tr><tr><td>仅 Worker（无缓存）</td><td>265ms</td><td>0ms</td><td>0%</td></tr><tr><td><strong>Worker + Cache</strong></td><td><strong>75ms</strong></td><td><strong>0ms</strong></td><td><strong>70%</strong></td></tr></tbody></table><p><strong>性能提升: 3.3x</strong> ✅ <strong>用户体验: 完全流畅</strong> ✅</p><h3 id="公式复杂度对比" tabindex="-1">公式复杂度对比 <a class="header-anchor" href="#公式复杂度对比" aria-label="Permalink to &quot;公式复杂度对比&quot;">​</a></h3><table tabindex="0"><thead><tr><th>类型</th><th>示例</th><th>首次渲染</th><th>缓存命中</th><th>提升</th></tr></thead><tbody><tr><td>简单</td><td><code>x = y</code></td><td>2ms</td><td>0.005ms</td><td>400x</td></tr><tr><td>中等</td><td><code>\\sum_{i=1}^{n}</code></td><td>10ms</td><td>0.008ms</td><td>1250x</td></tr><tr><td>复杂</td><td><code>\\int f(x) dx</code></td><td>30ms</td><td>0.01ms</td><td>3000x</td></tr></tbody></table><h2 id="为什么-cache-如此有效" tabindex="-1">为什么 Cache 如此有效？ <a class="header-anchor" href="#为什么-cache-如此有效" aria-label="Permalink to &quot;为什么 Cache 如此有效？&quot;">​</a></h2><h3 id="真实文档的特点" tabindex="-1">真实文档的特点： <a class="header-anchor" href="#真实文档的特点" aria-label="Permalink to &quot;真实文档的特点：&quot;">​</a></h3><ol><li><strong>高重复率</strong>：变量 <code>x</code>, <code>y</code>, <code>z</code> 经常出现</li><li><strong>模板公式</strong>：<code>\\sum</code>, <code>\\int</code> 等常见结构</li><li><strong>增量渲染</strong>：滚动、组件重新挂载会重复请求</li></ol><h3 id="实际缓存命中率统计" tabindex="-1">实际缓存命中率统计： <a class="header-anchor" href="#实际缓存命中率统计" aria-label="Permalink to &quot;实际缓存命中率统计：&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>数学文档:   70-85% 命中率</span></span>
<span class="line"><span>技术文档:   60-75% 命中率</span></span>
<span class="line"><span>教程文档:   75-90% 命中率（大量重复示例）</span></span></code></pre></div><h2 id="性能监控方法" tabindex="-1">性能监控方法 <a class="header-anchor" href="#性能监控方法" aria-label="Permalink to &quot;性能监控方法&quot;">​</a></h2><h3 id="方法-1-运行基准测试" tabindex="-1">方法 1: 运行基准测试 <a class="header-anchor" href="#方法-1-运行基准测试" aria-label="Permalink to &quot;方法 1: 运行基准测试&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test/benchmark/katex-worker-vs-direct.test.ts</span></span></code></pre></div><h3 id="方法-2-浏览器控制台" tabindex="-1">方法 2: 浏览器控制台 <a class="header-anchor" href="#方法-2-浏览器控制台" aria-label="Permalink to &quot;方法 2: 浏览器控制台&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 启用监控</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.__katexPerfMonitor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">enable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用应用...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 查看报告</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__katexPerfReport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="方法-3-chrome-devtools" tabindex="-1">方法 3: Chrome DevTools <a class="header-anchor" href="#方法-3-chrome-devtools" aria-label="Permalink to &quot;方法 3: Chrome DevTools&quot;">​</a></h3><ol><li>打开 Performance 标签</li><li>录制渲染过程</li><li>查看 Main 线程活动</li><li>检查是否有长任务（&gt;50ms）</li></ol><p><strong>判断标准:</strong></p><ul><li>✅ 如果看到 Main 线程有长时间黄色块 → Worker 有价值</li><li>✅ 如果 Worker 线程有独立活动 → Cache 在工作</li><li>⚠️ 如果两者都很空闲 → 公式太简单</li></ul><h2 id="决策树" tabindex="-1">决策树 <a class="header-anchor" href="#决策树" aria-label="Permalink to &quot;决策树&quot;">​</a></h2><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A[需要渲染数学公式?] --&gt;|是| B{公式复杂度?}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A --&gt;|否| Z[不需要 Worker]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    B --&gt;|简单 &lt;5ms| C{数量多吗?}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    B --&gt;|中等 5-20ms| D[✅ 使用 Worker + Cache]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    B --&gt;|复杂 &gt;20ms| D</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    C --&gt;|&lt;5 个| E[可选 Worker]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    C --&gt;|&gt;5 个| D</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    D --&gt; F{有重复公式吗?}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    F --&gt;|是 &gt;30%| G[✅✅ Cache 价值巨大!]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    F --&gt;|否| H[✅ Worker 仍防止阻塞]</span></span></code></pre></div><h2 id="最终建议" tabindex="-1">最终建议 <a class="header-anchor" href="#最终建议" aria-label="Permalink to &quot;最终建议&quot;">​</a></h2><h3 id="✅-保留当前架构" tabindex="-1">✅ <strong>保留当前架构</strong> <a class="header-anchor" href="#✅-保留当前架构" aria-label="Permalink to &quot;✅ **保留当前架构**&quot;">​</a></h3><p>你的代码已经是最佳实践：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 先检查 Cache（&lt;0.01ms）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cached</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cacheKey)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cached)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cached</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 使用 Worker 渲染（不阻塞主线程）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">renderKaTeXInWorker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(content)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 3. 保存到 Cache（未来受益）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cacheKey, html)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 4. Fallback 到直接渲染（稳定性）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    katex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">renderToString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(content)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span></code></pre></div><h3 id="优势总结" tabindex="-1">优势总结 <a class="header-anchor" href="#优势总结" aria-label="Permalink to &quot;优势总结&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>价值</th></tr></thead><tbody><tr><td>性能</td><td>✅✅✅ Cache 提升 500-5000x</td></tr><tr><td>体验</td><td>✅✅✅ Worker 避免 UI 卡顿</td></tr><tr><td>内存</td><td>✅✅✅ 仅 36KB (200 条)</td></tr><tr><td>稳定性</td><td>✅✅✅ Fallback 机制保底</td></tr><tr><td>维护性</td><td>✅✅ 代码清晰简洁</td></tr></tbody></table><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h2><h3 id="q-cache-会不会内存泄漏" tabindex="-1">Q: Cache 会不会内存泄漏？ <a class="header-anchor" href="#q-cache-会不会内存泄漏" aria-label="Permalink to &quot;Q: Cache 会不会内存泄漏？&quot;">​</a></h3><p><strong>A:</strong> 不会。使用 LRU 策略，限制最多 200 条。</p><h3 id="q-ssr-环境怎么办" tabindex="-1">Q: SSR 环境怎么办？ <a class="header-anchor" href="#q-ssr-环境怎么办" aria-label="Permalink to &quot;Q: SSR 环境怎么办？&quot;">​</a></h3><p><strong>A:</strong> 自动 fallback 到直接渲染，无需特殊处理。</p><h3 id="q-worker-初始化失败怎么办" tabindex="-1">Q: Worker 初始化失败怎么办？ <a class="header-anchor" href="#q-worker-初始化失败怎么办" aria-label="Permalink to &quot;Q: Worker 初始化失败怎么办？&quot;">​</a></h3><p><strong>A:</strong> 代码已处理，会 reject 并触发 fallback。</p><h3 id="q-需要手动管理-cache-吗" tabindex="-1">Q: 需要手动管理 Cache 吗？ <a class="header-anchor" href="#q-需要手动管理-cache-吗" aria-label="Permalink to &quot;Q: 需要手动管理 Cache 吗？&quot;">​</a></h3><p><strong>A:</strong> 不需要。自动管理，开发者零负担。</p><h2 id="性能优化技巧-可选" tabindex="-1">性能优化技巧（可选） <a class="header-anchor" href="#性能优化技巧-可选" aria-label="Permalink to &quot;性能优化技巧（可选）&quot;">​</a></h2><h3 id="_1-预热常见公式" tabindex="-1">1. 预热常见公式 <a class="header-anchor" href="#_1-预热常见公式" aria-label="Permalink to &quot;1. 预热常见公式&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> common</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;x&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;y&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;E=mc^2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">common.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> renderKaTeXInWorker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f))</span></span></code></pre></div><h3 id="_2-调整缓存大小" tabindex="-1">2. 调整缓存大小 <a class="header-anchor" href="#_2-调整缓存大小" aria-label="Permalink to &quot;2. 调整缓存大小&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果有大量唯一公式</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CACHE_MAX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 默认 200</span></span></code></pre></div><h3 id="_3-使用-requestidlecallback" tabindex="-1">3. 使用 requestIdleCallback <a class="header-anchor" href="#_3-使用-requestidlecallback" aria-label="Permalink to &quot;3. 使用 requestIdleCallback&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestIdleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在浏览器空闲时预渲染</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  renderKaTeXInWorker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(formula)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h2><p><strong>Worker 的 Cache 不仅有意义，而且是性能关键！</strong></p><ul><li>✅ 提升性能 3-10 倍</li><li>✅ 改善用户体验（无卡顿）</li><li>✅ 内存占用可忽略</li><li>✅ 代码维护性好</li></ul><p><strong>不要删除 Cache！它是整个架构的核心价值所在。</strong> 🎯</p><h2 id="组件级回退策略与差异-inline-vs-block" tabindex="-1">组件级回退策略与差异（Inline vs Block） <a class="header-anchor" href="#组件级回退策略与差异-inline-vs-block" aria-label="Permalink to &quot;组件级回退策略与差异（Inline vs Block）&quot;">​</a></h2><p>为保证在高并发/高压力场景下不出现“无限 Loading”，组件层实现了差异化回退策略：</p><ul><li><p>MathBlock（块级公式）</p><ul><li>优先使用 Worker 渲染。</li><li>Worker 初始化失败（code: WORKER_INIT_ERROR）时，回退到主线程同步渲染（katex.renderToString，displayMode: true）。</li><li>同步渲染成功后，会通过 setKaTeXCache 预热 Worker 客户端缓存（key 区分 displayMode），以便后续同一公式命中缓存、避免重复成本。</li></ul></li><li><p>MathInline（行内公式）</p><ul><li>优先使用 Worker 渲染，带回压重试。</li><li>发生以下错误时会尝试主线程同步渲染（displayMode: false），避免长时间处于 Loading： <ul><li>WORKER_INIT_ERROR（Worker 初始化失败）</li><li>WORKER_BUSY（达到并发上限，忙）</li><li>WORKER_TIMEOUT（单次 Worker 渲染超时）</li></ul></li><li>如果同步渲染不可用或失败，将停止 Loading 并回退展示原始文本（raw），确保用户不看到“永久转圈”。</li><li>默认不调用 setKaTeXCache 进行缓存预热（与块级不同）；这样做是出于实现简洁和收益权衡。若需要最大化命中率，可在同步回退成功后调用缓存预热（可选）。</li></ul></li></ul><h3 id="设计权衡" tabindex="-1">设计权衡 <a class="header-anchor" href="#设计权衡" aria-label="Permalink to &quot;设计权衡&quot;">​</a></h3><ul><li>行内公式通常更轻量、数量更多且重复度不稳定，主线程同步一次的代价较小，因此在 Worker 繁忙/超时时进行同步回退能显著改善体验。</li><li>块级公式复杂度和复用度通常更高，缓存预热能带来更明显的收益，所以默认启用。</li></ul><h3 id="相关错误码" tabindex="-1">相关错误码 <a class="header-anchor" href="#相关错误码" aria-label="Permalink to &quot;相关错误码&quot;">​</a></h3><ul><li>WORKER_INIT_ERROR：未注入/未能初始化 Worker；需要回退到主线程。</li><li>WORKER_BUSY（常量：WORKER_BUSY_CODE）：达到并发上限；可等待或回退。</li><li>WORKER_TIMEOUT（name/code：&quot;WorkerTimeout&quot;/&quot;WORKER_TIMEOUT&quot;）：单次渲染超时；可回退。</li></ul><h3 id="可选增强-按需开启" tabindex="-1">可选增强（按需开启） <a class="header-anchor" href="#可选增强-按需开启" aria-label="Permalink to &quot;可选增强（按需开启）&quot;">​</a></h3><ul><li>如需让行内公式也享受回退后的缓存命中，可在同步渲染成功后调用 setKaTeXCache(content, false, html)。</li><li>若极端场景中担心主线程压力，可仅对超时（WORKER_TIMEOUT）而不是忙（WORKER_BUSY）启用同步回退，或增加等待窗口后再回退。</li></ul>`,67)])])}const g=s(n,[["render",l]]);export{c as __pageData,g as default};
