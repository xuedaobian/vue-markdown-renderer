import{_ as r,c as a,o,ag as t}from"./chunks/framework.CA53vVaN.js";const c=JSON.parse('{"title":"KaTeX Worker 性能分析指南（中文）","description":"","frontmatter":{},"headers":[],"relativePath":"zh/guide/katex-worker-performance-analysis.md","filePath":"zh/guide/katex-worker-performance-analysis.md"}'),i={name:"zh/guide/katex-worker-performance-analysis.md"};function l(n,e,s,h,d,k){return o(),a("div",null,[...e[0]||(e[0]=[t('<p>// Copied KaTeX zh page to the guide subfolder for proper zh routing</p><h1 id="katex-worker-性能分析指南-中文" tabindex="-1">KaTeX Worker 性能分析指南（中文） <a class="header-anchor" href="#katex-worker-性能分析指南-中文" aria-label="Permalink to &quot;KaTeX Worker 性能分析指南（中文）&quot;">​</a></h1><h2 id="问题-worker-是否比直接渲染更合适" tabindex="-1">问题：Worker 是否比直接渲染更合适？ <a class="header-anchor" href="#问题-worker-是否比直接渲染更合适" aria-label="Permalink to &quot;问题：Worker 是否比直接渲染更合适？&quot;">​</a></h2><p>本文档帮助你判断在何种场景下使用 Web Worker 会带来性能优势。</p><h2 id="快速结论" tabindex="-1">快速结论 <a class="header-anchor" href="#快速结论" aria-label="Permalink to &quot;快速结论&quot;">​</a></h2><p><strong>是的，Worker + Cache 架构在大多数真实场景中有显著优势。</strong></p><p>关键原因：</p><ol><li>Cache 能消除大部分重复渲染开销（缓存命中率通常 &gt;70%）</li><li>Worker 能阻止主线程被阻塞，从而保证 UI 响应</li><li>内存占用极小（举例：200 个公式大约 10–50KB）</li></ol><h2 id="简要对比-场景" tabindex="-1">简要对比（场景） <a class="header-anchor" href="#简要对比-场景" aria-label="Permalink to &quot;简要对比（场景）&quot;">​</a></h2><ul><li>场景：单个简单公式 <ul><li>直接渲染：约 2–5ms</li><li>Worker：约 3–7ms（含通信开销）</li><li>结论：Worker 略慢，但差异可以忽略</li></ul></li></ul><p>... (rest of content copied from top-level zh KaTeX) ...</p>',11)])])}const u=r(i,[["render",l]]);export{c as __pageData,u as default};
